// src/InputStream.ts
function InputStream(input) {
  let pos = 0;
  let line = 1;
  let col = 0;
  return {
    next,
    peek,
    eof,
    croak,
    position: () => pos
  };
  function next(count = 1) {
    let val = "";
    for (let i = 0; i < count; i++) {
      const ch = input.charAt(pos++);
      if (ch === "\n") {
        line++;
        col = 0;
      } else {
        col++;
      }
      val += ch;
    }
    return val;
  }
  function peek(length = 1) {
    if (length === 1) {
      return input.charAt(pos);
    }
    let val = "";
    for (let i = 0; i < length; i++) {
      val += input.charAt(pos + i);
    }
    return val;
  }
  function eof() {
    return peek() === "";
  }
  function croak(msg) {
    throw new Error(msg + " (" + line + ":" + col + ")");
  }
}

// src/constants.ts
var SINGLE_QUOTE = "'";
var DOUBLE_QUOTE = '"';
var BACKTICK = "`";

// src/Parser.ts
var Parser = {
  parse,
  parseOne
};
function parseOne(file) {
  const input = InputStream(file);
  const res = parseInternal(input);
  return {
    value: res,
    length: input.position()
  };
}
function parse(file) {
  const input = InputStream(file);
  const res = parseInternal(input);
  if (input.eof()) {
    return res;
  }
  input.croak(`Expected EOF`);
}
function parseInternal(input) {
  return root();
  function root() {
    skipWhitespacesAndComments();
    const expr = parseExpression();
    skipWhitespacesAndComments();
    return expr;
  }
  function parseExpression() {
    const ch = input.peek();
    if (ch === "{") {
      return parseObject();
    }
    if (ch === "[") {
      return parseArray();
    }
    if (ch === "-") {
      input.next();
      return parseNumber(true);
    }
    if (ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE || ch === BACKTICK) {
      return parseString(ch);
    }
    if (isDigit(ch)) {
      return parseNumber();
    }
    if (isIdentifier("true")) {
      skipIdentifier("true");
      return true;
    }
    if (isIdentifier("false")) {
      skipIdentifier("false");
      return false;
    }
    if (isIdentifier("null")) {
      skipIdentifier("null");
      return null;
    }
    if (isIdentifier("undefined")) {
      skipIdentifier("undefined");
      return void 0;
    }
    if (input.eof()) {
      return input.croak(`Unexpected empty string`);
    }
    return input.croak(`Unexpected "${ch}"`);
  }
  function skipIdentifier(identifier) {
    const next = input.next(identifier.length);
    if (next !== identifier) {
      input.croak(`Expected identifier "${identifier}" got "${next}"`);
    }
    return next;
  }
  function isIdentifier(identifier) {
    if (input.peek(identifier.length) === identifier) {
      const after = input.peek(identifier.length + 1)[identifier.length];
      return after === void 0 || isNameChar(after) === false;
    }
    return false;
  }
  function isDigit(ch) {
    return /[0-9]/i.test(ch);
  }
  function isNameStart(ch) {
    return /[a-zA-Z_]/i.test(ch);
  }
  function isNameChar(ch) {
    return isNameStart(ch) || "0123456789_".indexOf(ch) >= 0;
  }
  function skipWhitespacesAndComments() {
    let didSomething;
    do {
      didSomething = skipComment() || skipWhitespaces();
    } while (didSomething);
  }
  function skipComment() {
    if (input.peek(2) === "//") {
      input.next();
      input.next();
      skipUntil("\n");
      return true;
    }
    if (input.peek(2) === "/*") {
      input.next();
      input.next();
      skipUntil("*/");
      input.next();
      input.next();
      return true;
    }
    return false;
  }
  function isWhitspace(char) {
    return char === " " || char === "	" || char === "\n";
  }
  function skipWhitespaces() {
    if (!isWhitspace(input.peek())) {
      return false;
    }
    while (!input.eof() && isWhitspace(input.peek())) {
      input.next();
    }
    return true;
  }
  function skipUntil(condition) {
    while (!input.eof() && input.peek(condition.length) !== condition) {
      input.next();
    }
  }
  function parseNumber(negative = false) {
    let hasDot = false;
    const number = readWhile((ch) => {
      if (ch === ".") {
        if (hasDot) {
          return false;
        }
        hasDot = true;
        return true;
      }
      return isDigit(ch);
    });
    return parseFloat(number) * (negative ? -1 : 1);
  }
  function parseArray() {
    skip("[");
    const arr = [];
    skipWhitespacesAndComments();
    if (input.peek() === "]") {
      skip("]");
      return arr;
    }
    while (!input.eof() && input.peek() !== "]") {
      const value = parseExpression();
      skipWhitespacesAndComments();
      arr.push(value);
      const foundComma = maybeSkip(",");
      if (!foundComma) {
        break;
      }
      skipWhitespacesAndComments();
    }
    skip("]");
    return arr;
  }
  function parseObject() {
    skip("{");
    const obj = {};
    skipWhitespacesAndComments();
    if (input.peek() === "}") {
      skip("}");
      return obj;
    }
    while (!input.eof() && input.peek() !== "}") {
      const key = parseKey();
      skip(":");
      skipWhitespacesAndComments();
      const value = parseExpression();
      skipWhitespacesAndComments();
      obj[key] = value;
      const foundComma = maybeSkip(",");
      if (!foundComma) {
        break;
      }
      skipWhitespacesAndComments();
    }
    skip("}");
    return obj;
  }
  function parseKey() {
    const next = input.peek();
    if (isDigit(input.peek())) {
      const res = parseNumber();
      return res;
    }
    if (next === SINGLE_QUOTE || next === DOUBLE_QUOTE) {
      return parseString(next);
    }
    if (input.peek() === "[") {
      skip("[");
      const expr = parseExpression();
      skip("]");
      return expr;
    }
    if (isNameStart(input.peek())) {
      return readWhile(isNameChar);
    }
    return input.croak(`Unexpected "${input.peek()}"`);
  }
  function readWhile(predicate) {
    let str = "";
    while (!input.eof() && predicate(input.peek())) {
      str += input.next();
    }
    return str;
  }
  function parseString(end) {
    let escaped = false;
    let str = "";
    input.next();
    while (!input.eof()) {
      const ch = input.next();
      if (end !== BACKTICK && ch === "\n") {
        break;
      }
      if (escaped) {
        str += ch;
        escaped = false;
      } else if (ch === end) {
        break;
      } else if (ch === "\\") {
        escaped = true;
      } else {
        str += ch;
      }
    }
    return str;
  }
  function skip(char) {
    if (input.peek() !== char) {
      input.croak(`Expected ${char} got ${input.peek()}`);
    }
    input.next();
  }
  function maybeSkip(char) {
    if (input.peek() === char) {
      input.next();
      return true;
    }
    return false;
  }
}

// src/Serializer.ts
var Serializer = {
  serialize
};
function serialize(obj, format = "line") {
  try {
    JSON.stringify(obj);
  } catch (error) {
    throw new Error(`Value not compatible with JSON.stringify`);
  }
  const formatObj = resolveFormatObj(format);
  const items = printItems(obj);
  return formatPrintItems(items, formatObj, 0);
  function printItems(obj2) {
    if (obj2 === null) {
      return ["null"];
    }
    if (obj2 === void 0) {
      return ["undefined"];
    }
    if (obj2 === true) {
      return ["true"];
    }
    if (obj2 === false) {
      return ["false"];
    }
    if (typeof obj2 === "string") {
      return [serializeString(obj2)];
    }
    if (typeof obj2 === "number") {
      if (Number.isFinite(obj2)) {
        return [obj2.toString()];
      }
    }
    if (Array.isArray(obj2)) {
      const items2 = [];
      items2.push("[");
      if (obj2.length === 0) {
        items2.push("]");
        return items2;
      }
      items2.push({ type: "IndentArr" });
      obj2.forEach((item, index) => {
        if (index > 0) {
          items2.push(",");
          items2.push({ type: "Line" });
        }
        items2.push(...printItems(item));
      });
      items2.push({ type: "DedentArr" });
      items2.push("]");
      return [{ type: "Group", items: items2 }];
    }
    if (isPlainObject(obj2)) {
      return objectPrintItems(obj2);
    }
    console.log(obj2);
    throw new Error(`Unsuported type ${typeof obj2}`);
  }
  function objectPrintItems(obj2) {
    const items2 = [];
    items2.push("{");
    const keys = Object.keys(obj2);
    if (keys.length === 0) {
      items2.push("}");
      return items2;
    }
    items2.push({ type: "IndentObj" });
    keys.forEach((key, index) => {
      if (index > 0) {
        items2.push(",");
        items2.push({ type: "Line" });
      }
      items2.push(serializeKey(key));
      items2.push(":");
      items2.push({ type: "Space" });
      items2.push(...printItems(obj2[key]));
    });
    items2.push({ type: "DedentObj" });
    items2.push("}");
    return [{ type: "Group", items: items2 }];
  }
  function serializeKey(key) {
    if (typeof key === "number") {
      return key.toString();
    }
    if (key.match(/^[A-Za-z0-9][A-Za-z0-9_]+$/)) {
      return key;
    }
    return serializeString(key);
  }
  function serializeString(obj2) {
    const hasSingle = obj2.indexOf(SINGLE_QUOTE) >= 0;
    if (!hasSingle) {
      return `'${obj2}'`;
    }
    const hasDouble = obj2.indexOf(DOUBLE_QUOTE) >= 0;
    if (!hasDouble) {
      return `"${obj2}"`;
    }
    const hasBacktick = obj2.indexOf(BACKTICK) >= 0;
    if (!hasBacktick) {
      return "`" + obj2 + "`";
    }
    return `'${obj2.replace(/'/g, `\\'`)}'`;
  }
}
function formatPrintItems(items, format, baseDepth) {
  let result = "";
  let depth = baseDepth;
  items.forEach((item) => {
    if (typeof item === "string") {
      result += item;
      return;
    }
    if (format.mode === "compact") {
      if (item.type === "Group") {
        result += formatPrintItems(item.items, format, depth);
        return;
      }
      return;
    }
    if (format.mode === "line") {
      switch (item.type) {
        case "Group":
          result += formatPrintItems(item.items, format, depth);
          return;
        case "Line":
        case "Space":
          result += " ";
          return;
        case "IndentArr":
        case "DedentArr":
          return;
        case "IndentObj":
        case "DedentObj":
          result += " ";
          return;
        default:
          return;
      }
    }
    if (format.mode === "indent") {
      const { space = 2 } = format;
      const padding = " ".repeat(space);
      switch (item.type) {
        case "Group":
          result += formatPrintItems(item.items, format, depth);
          return;
        case "Line":
          result += "\n" + padding.repeat(depth);
          return;
        case "IndentArr":
        case "IndentObj":
          depth += 1;
          result += "\n" + padding.repeat(depth);
          return;
        case "DedentArr":
        case "DedentObj":
          depth -= 1;
          result += "\n" + padding.repeat(depth);
          return;
        case "Space":
          result += " ";
          return;
        default:
          return;
      }
    }
    if (format.mode === "pretty") {
      const { space = 2, threshold = 80 } = format;
      const padding = " ".repeat(space);
      switch (item.type) {
        case "Group":
          const line = formatPrintItems(item.items, { mode: "line" }, depth);
          if (line.length <= threshold) {
            result += line;
            return;
          }
          result += formatPrintItems(item.items, format, depth);
          return;
        case "Line":
          result += "\n" + padding.repeat(depth);
          return;
        case "IndentArr":
        case "IndentObj":
          depth += 1;
          result += "\n" + padding.repeat(depth);
          return;
        case "DedentArr":
        case "DedentObj":
          depth -= 1;
          result += "\n" + padding.repeat(depth);
          return;
        case "Space":
          result += " ";
          return;
        default:
          return;
      }
    }
    throw new Error(`Unsuported format ${format}`);
  });
  return result;
}
function isObject(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
}
function isObjectObject(o) {
  return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  if (isObjectObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (typeof ctor !== "function")
    return false;
  const prot = ctor.prototype;
  if (isObjectObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function resolveFormatObj(format) {
  if (typeof format === "number") {
    return { mode: "indent", space: format };
  }
  if (format === "compact") {
    return { mode: "compact" };
  }
  if (format === "indent") {
    return { mode: "indent", space: 2 };
  }
  if (format === "line") {
    return { mode: "line" };
  }
  if (format === "pretty") {
    return { mode: "pretty", threshold: 80, space: 2 };
  }
  return format;
}
export {
  Parser,
  Serializer
};
